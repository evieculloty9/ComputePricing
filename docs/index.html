<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/dayjs@1/dayjs.min.js"></script>
<script>
  // ------------------ CONFIG (relative to /docs) ------------------
  const PATHS = {
    scores: 'data/derived/provider_scores_latest.csv',
    roi:    'data/derived/roi_comparison.csv',
    market: 'data/derived/market_index.csv'
  };

  // ------------------ Helpers ------------------
  const $ = sel => document.querySelector(sel);
  const $$ = sel => Array.from(document.querySelectorAll(sel));
  const fmtUSD = v => (v===null||v===undefined||v==='') ? '–' : `$${Number(v).toFixed(2)}`;
  const numify = v => {
    if (v===null || v===undefined) return null;
    const s = String(v).trim(); if (!s) return null;
    const x = parseFloat(s.replace(/[^\d.\-]/g,''));
    return Number.isFinite(x) ? x : null;
  };
  const clean = s => (s ?? '').toString().trim();
  const shortTs = s => { if(!s) return '–'; try { return dayjs(s).format('YYYY-MM-DD HH:mm'); } catch { return s; } };
  const toHours = (label) => ({'1 hour':1,'1 day':24,'1 week':168,'1 month':720}[label] ?? 1);
  function showErr(msg){ const el = $('#err'); el.textContent = msg; el.classList.remove('hidden'); console.error(msg); }

  // Robust fetch + parse (no Papa download mode; avoids path quirks)
  async function loadCSV(path, label){
    const url = new URL(path, new URL('.', location.href)).href;
    const bust = url + (url.includes('?')?'&':'?') + '_=' + Date.now();
    const res = await fetch(bust, {cache:'no-store'});
    const text = await res.text();
    if (!res.ok || !text.length){
      showErr(`[${label}] HTTP ${res.status}; bytes=${text.length}; url=${url}`);
      return {rows:[], meta:{status:res.status, bytes:text.length}};
    }
    const parsed = Papa.parse(text, {header:true, dynamicTyping:false, skipEmptyLines:true});
    if (parsed.errors?.length) console.warn(`[${label}] Papa errors`, parsed.errors.slice(0,3));
    const rows = parsed.data || [];
    if (!rows.length) showErr(`[${label}] parsed 0 rows; bytes=${text.length}; url=${url}`);
    return {rows, meta:{status:res.status, bytes:text.length}};
  }

  // ------------------ STATE ------------------
  const state = { raw: [], filtered: [], asc:true, market: [], roi: [] };

  // ------------------ LOAD + NORMALIZE ------------------
  function normalizeScores(rows){
    return rows.map(o=>{
      const r = {...o};
      if (r["\ufeffprovider"] && !r.provider) r.provider = r["\ufeffprovider"]; // BOM guard

      r.provider  = r.provider ?? r.Provider ?? r.name ?? '';
      r.region    = r.region ?? r.Region ?? 'Global';
      r.gpu_model = (r.gpu_model ?? r.gpu ?? r.model ?? '').toString().toUpperCase();
      r.type      = r.type ?? r.price_type ?? '';      // may be empty
      r.gpu_count = r.gpu_count ?? r.count ?? r.GPU_count ?? '';
      r.duration  = r.duration ?? r.reserved_duration ?? r.term ?? '';
      r.timestamp = r.timestamp ?? r.asof_utc ?? r.fetched_at_utc ?? r.ts_utc ?? r.ts_iso ?? '';
      r.priceiq_score = numify(r.priceiq_score ?? r.score);

      // prices
      r.effective_price_usd_per_gpu_hr =
        numify(r.effective_price_usd_per_gpu_hr ?? r.usd_per_gpu_hr ?? r.effective_price ?? r.price_hourly_usd_per_gpu);
      r.price_hourly_usd   = numify(r.price_hourly_usd ?? r.price);
      r.price_reserved_usd = numify(r.price_reserved_usd ?? r.reserved_price ?? r.reserved_usd_per_gpu_hr);

      return r;
    });
  }

  function buildUniques(){
    const uniq = (arr, key) => Array.from(new Set(arr.map(x=>clean(x[key])))).filter(Boolean).sort((a,b)=>String(a).localeCompare(String(b)));
    return {
      gpu: uniq(state.raw, 'gpu_model'),
      region: uniq(state.raw, 'region'),
      duration: uniq(state.raw, 'duration'),
      count: uniq(state.raw, 'gpu_count')
    };
  }

  function populateFilters(u){
    const add = (el, vals) => { el.innerHTML = '<option value="">All</option>' + vals.map(v=>`<option>${v}</option>`).join(''); };
    add($('#fGpu'), u.gpu);
    add($('#fRegion'), u.region);
    add($('#fDuration'), u.duration);
    add($('#fCount'), u.count);
  }

  function inferType(row){
    const on = row.price_hourly_usd;
    const rs = row.price_reserved_usd;
    if(on != null && rs == null) return 'On-Demand';
    if(rs != null && on == null) return 'Reserved';
    if(on != null && rs != null) return 'On-Demand';
    return row.type || '';
  }

  function applyFilters(){
    const g = $('#fGpu').value, r = $('#fRegion').value, t = $('#fType').value, d = $('#fDuration').value, c = $('#fCount').value;

    state.filtered = state.raw.filter(x=>{
      const type = inferType(x);
      return (!g || clean(x.gpu_model)===g) &&
             (!r || clean(x.region)===r) &&
             (!t || type===t) &&
             (!d || clean(x.duration)===d) &&
             (!c || clean(x.gpu_count)===c);
    });

    state.filtered.sort((a,b)=>{
      const pa = a.effective_price_usd_per_gpu_hr ?? a.price_hourly_usd ?? a.price_reserved_usd ?? Infinity;
      const pb = b.effective_price_usd_per_gpu_hr ?? b.price_hourly_usd ?? b.price_reserved_usd ?? Infinity;
      return state.asc ? (pa - pb) : (pb - pa);
    });

    renderLeaderboard();
    renderKpis();
  }

  function renderKpis(){
    const prices = state.filtered
      .map(x => x.effective_price_usd_per_gpu_hr ?? x.price_hourly_usd ?? x.price_reserved_usd)
      .filter(v => v!=null && !Number.isNaN(v));
    const cheapest = prices.length ? Math.min(...prices) : null;
    const median = prices.length ? prices.slice().sort((a,b)=>a-b)[Math.floor(prices.length/2)] : null;

    $('#kpiCheapest').textContent = fmtUSD(cheapest);
    $('#kpiMedian').textContent = fmtUSD(median);
    $('#kpiRows').textContent = state.filtered.length.toLocaleString();
    $('#kpiProviders').textContent = new Set(state.filtered.map(x=>clean(x.provider))).size || '–';

    if(cheapest!==null){
      const row = state.filtered.find(x => (x.effective_price_usd_per_gpu_hr ?? x.price_hourly_usd ?? x.price_reserved_usd) === cheapest);
      $('#kpiCheapestMeta').textContent = row ? `${clean(row.provider)} · ${clean(row.region)} · ${clean(row.gpu_model)} (${inferType(row)})` : '';
    } else $('#kpiCheapestMeta').textContent = '';
    $('#kpiMedianMeta').textContent = prices.length ? `${prices.length} quotes` : '';
  }

  function renderLeaderboard(){
    const body = $('#lbBody'); body.innerHTML = '';
    for(const row of state.filtered){
      const type = inferType(row);
      const price = row.effective_price_usd_per_gpu_hr ?? row.price_hourly_usd ?? row.price_reserved_usd;
      const score = row.priceiq_score ?? '';
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td class="px-5 py-3 font-medium">${clean(row.provider)}</td>
        <td class="px-5 py-3">${clean(row.region)||'Global'}</td>
        <td class="px-5 py-3">${clean(row.gpu_model)}</td>
        <td class="px-5 py-3">${type ? `<span class="badge ${type==='Reserved' ? 'badge-res':'badge-on'}">${type}</span>` : '–'}</td>
        <td class="px-5 py-3">${clean(row.duration)||'–'}</td>
        <td class="px-5 py-3">${clean(row.gpu_count)||'–'}</td>
        <td class="px-5 py-3 text-right">${fmtUSD(price)}</td>
        <td class="px-5 py-3 text-right">${score ? Number(score).toFixed(2) : '–'}</td>
        <td class="px-5 py-3">${shortTs(row.timestamp)}</td>
      `;
      body.appendChild(tr);
    }
  }

  // ------------------ ROI (precomputed) ------------------
  function renderRoiTable(rows){
    if(!rows?.length) return;
    const head = Object.keys(rows[0]);
    const thead = $('#roiHead');
    thead.innerHTML = `<tr>${head.map(h=>`<th class="text-left px-5 py-3">${h}</th>`).join('')}</tr>`;
    const tbody = $('#roiBody');
    tbody.innerHTML = rows.map(r=>{
      return `<tr>${head.map(h=>{
        let v = r[h];
        if(/price|cost|usd|per_gpu_hr/i.test(h)) v = fmtUSD(numify(v));
        return `<td class="px-5 py-3">${(v ?? '–')}</td>`;
      }).join('')}</tr>`;
    }).join('');
  }

  // ------------------ ROI Calculator (uses market p50 optionally) ------------------
  function initRoiCalcControls(){
    const gpuSel = $('#rcGpu'), regSel = $('#rcRegion'), provSel = $('#rcProvider');
    const gpus = Array.from(new Set(state.raw.map(x=>clean(x.gpu_model)))).filter(Boolean).sort();
    const regs = Array.from(new Set(state.raw.map(x=>clean(x.region)||"Global"))).filter(Boolean).sort();
    const provs = Array.from(new Set(state.raw.map(x=>clean(x.provider)))).filter(Boolean).sort();

    gpuSel.innerHTML = gpus.map(g=>`<option>${g}</option>`).join('');
    regSel.innerHTML = ['Global', ...regs.filter(r=>r!=='Global')].map(r=>`<option>${r}</option>`).join('');
    provSel.innerHTML = `<option value="">All providers</option>` + provs.map(p=>`<option>${p}</option>`).join('');
  }

  function runRoiCalc(){
    const gpu = $('#rcGpu').value;
    const region = $('#rcRegion').value;
    const cnt = Math.max(1, Number($('#rcCount').value||1));
    const hrs = toHours($('#rcDuration').value);
    const util = Math.min(100, Math.max(1, Number($('#rcUtil').value||100))) / 100;
    const providerFilter = $('#rcProvider').value;
    const useP50 = $('#rcUsePred').checked;

    const pool = state.raw.filter(r =>
      clean(r.gpu_model)===gpu &&
      (!providerFilter || clean(r.provider)===providerFilter) &&
      (region==='' || clean(r.region||'Global')===region || clean(r.region).toLowerCase()==='global')
    );

    const lines = [];

    if (useP50 && state.market.length){
      let mr = state.market.find(m => clean(m.gpu_model)===gpu && clean(m.region)===region) ||
               state.market.find(m => clean(m.gpu_model)===gpu && clean(m.region).toLowerCase()==='global') ||
               state.market.find(m => clean(m.gpu_model)===gpu);
      if (mr && numify(mr.market_median)!=null){
        const price = numify(mr.market_median);
        lines.push({provider:"Market P50", region: mr.region || region || '—', price, total: price*cnt*hrs*util, source:"market_index.csv"});
      }
    }

    if (pool.length){
      const best = [...pool].sort((a,b)=>{
        const pa = a.effective_price_usd_per_gpu_hr ?? a.price_hourly_usd ?? a.price_reserved_usd ?? Infinity;
        const pb = b.effective_price_usd_per_gpu_hr ?? b.price_hourly_usd ?? b.price_reserved_usd ?? Infinity;
        return pa - pb;
      })[0];
      const price = best.effective_price_usd_per_gpu_hr ?? best.price_hourly_usd ?? best.price_reserved_usd;
      if (price!=null){
        lines.push({provider: clean(best.provider), region: clean(best.region)||'Global', price, total: price*cnt*hrs*util, source:"provider_scores_latest.csv"});
      }
    }

    lines.sort((a,b)=>a.total-b.total);
    const body = $('#rcBody'); body.innerHTML='';
    for(const row of lines){
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td class="px-5 py-3 font-medium">${row.provider}</td>
        <td class="px-5 py-3">${row.region}</td>
        <td class="px-5 py-3 text-right">${fmtUSD(row.price)}</td>
        <td class="px-5 py-3 text-right">${fmtUSD(row.total)}</td>
        <td class="px-5 py-3">${row.source}</td>
      `;
      body.appendChild(tr);
    }
    $('#rcNote').textContent = lines.length ? `${lines.length} option(s)` : 'No matching options';
  }

  // ------------------ Events & Boot ------------------
  $('#clearBtn').addEventListener('click', ()=>{
    $$('#fGpu,#fRegion,#fType,#fDuration,#fCount').forEach(s=>s.value='');
    applyFilters();
  });
  $$('#fGpu,#fRegion,#fType,#fDuration,#fCount').forEach(s=>s.addEventListener('change', applyFilters));
  $('#sortBtn').addEventListener('click', ()=>{
    state.asc = !state.asc;
    $('#sortBtn').textContent = state.asc ? 'Price ↑' : 'Price ↓';
    applyFilters();
  });
  $('#rcCalc').addEventListener('click', runRoiCalc);
  $('#rcUsePred').addEventListener('change', runRoiCalc);

  (async function init(){
    try{
      const [{rows:scoresRows, meta:sm},{rows:roiRows},{rows:marketRows}] = await Promise.all([
        loadCSV(PATHS.scores,'scores'),
        loadCSV(PATHS.roi,'roi'),
        loadCSV(PATHS.market,'market')
      ]);

      state.raw = normalizeScores(scoresRows).filter(r =>
        r.effective_price_usd_per_gpu_hr != null ||
        r.price_hourly_usd != null ||
        r.price_reserved_usd != null
      );

      state.market = (marketRows||[]).map(m=>({
        gpu_model: (m.gpu_model||'').toString().toUpperCase(),
        region: clean(m.region)||'Global',
        market_count: numify(m.market_count),
        market_mean: numify(m.market_mean),
        market_median: numify(m.market_median),
        market_p10: numify(m.market_p10),
        market_p25: numify(m.market_p25),
        market_p75: numify(m.market_p75),
        market_p90: numify(m.market_p90)
      }));

      renderRoiTable(roiRows||[]);

      const lastTs = (state.raw.map(r=>r.timestamp).filter(Boolean).sort().pop()) || null;
      $('#lastUpdated').textContent = lastTs ? shortTs(lastTs) : `HTTP ${sm?.status||'?'} • bytes=${sm?.bytes||'?'}`;

      populateFilters(buildUniques());
      applyFilters();

      initRoiCalcControls();
      runRoiCalc();

      if (!state.raw.length) showErr("No usable rows in provider_scores_latest.csv");
    }catch(e){
      showErr("Fatal init error: " + (e?.message||e));
    }
  })();
</script>





